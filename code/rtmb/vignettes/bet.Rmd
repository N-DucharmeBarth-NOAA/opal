---
title: "The BET model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The BET model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: "references.bib"
link-citations: yes
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

# Introduction

The `sbt` software is an R package [@R2024] that contains the CCSBT operating 
model (OM) coded using RTMB [@Kristensen2016, @Kristensen2024]. This page 
provides examples using the `sbt` model.

# Load inputs

The `sbt` RTMB model is loaded along with several R functions using 
`library(sbt)`. The `kableExtra` package is used for generating tables of 
inputs. The `tidyverse` package is used for data manipulation and plotting. The 
code `theme_set(theme_bw())` alters the plot aesthetics.

```{r load-pkg, echo=TRUE, message=FALSE}
# remotes::install_github("janoleko/RTMBdist")
# remotes::install_github("andrjohns/StanEstimators")
# remotes::install_github("noaa-afsc/SparseNUTS")
library(kableExtra)
library(tidyverse)
library(reshape2)
library(this.path)
library(RTMB)
# Load MFCL files to extract biology
library(FLR4MFCL)
library(data.table)
library(magrittr)
# library(bet)

theme_set(theme_bw())
proj_dir <- this.path::this.proj()
sapply(file.path(proj_dir, "code", "rtmb","R", list.files(file.path(proj_dir, "code", "rtmb","R"))), source)

# setwd("~/Projects/wcpfc-bet-single-region/code/rtmb")
# devtools::load_all()

# proj_dir <- this.path::this.proj()
# devtools::load_all(file.path(proj_dir, "code", "rtmb"))
# sapply(file.path(proj_dir, "code", "rtmb","R", list.files(file.path(proj_dir, "code", "rtmb","R"))), source)
```

```{r get-biology, echo=TRUE, message=FALSE}
# proj_dir <- "~/Projects/wcpfc-bet-single-region"
dir_model <- file.path(proj_dir, "model-files")
dir_base_mfcl <- file.path(dir_model, "mfcl", "v11")

# Read MFCL files
base_par <- read.MFCLPar(file.path(dir_base_mfcl, "10.par"), first.yr = 1952)
base_rep <- read.MFCLRep(file.path(dir_base_mfcl, "plot-10.par.rep"))
base_ini <- read.MFCLIni(file.path(dir_base_mfcl, "bet.ini"), nseasons = 4)

# Quarterly age classes matching MFCL/SS3: ages 1-40 represent 0.25-10.0 real years
ages <- 1:40

# Growth parameters from MFCL (used to initialise leading parameters)
# Extract mean length-at-age and SD from MFCL report
tmp_laa_dt <- as.data.table(mean_laa(base_rep))
tmp_sdlaa_dt <- as.data.table(sd_laa(base_rep))

# Mean length-at-age by quarter (40 quarterly ages)
mean_length_at_age <- tmp_laa_dt$value

# SD of length-at-age by quarter
sd_length_at_age <- tmp_sdlaa_dt$value

# Reference ages matching SS3: Growth_Age_for_L1 = 1, Growth_Age_for_L2 = 40
A1 <- 1L
A2 <- 40L

# Default growth/variability parameter values from MFCL baseline
L1_init  <- growth(base_par)[1, 1] # VB length at age 1 (0.25 years)
L2_init  <- growth(base_par)[2, 1] # VB length at age 40 (10 years)
k_init   <- growth(base_par)[3, 1]  # VB growth rate from MFCL
CV1_init <- sd_length_at_age[A1] / mean_length_at_age[A1]
CV2_init <- sd_length_at_age[A2] / mean_length_at_age[A2]

# Plot mean length-at-age
plot_data <- data.frame(
  age = ages,
  real_age = ages / 4,  # convert to real years
  length_cm = mean_length_at_age,
  sd = sd_length_at_age
)

ggplot(data = plot_data, aes(x = real_age, y = length_cm)) +
  geom_ribbon(aes(ymin = length_cm - sd, ymax = length_cm + sd), alpha = 0.2) +
  geom_line() +
  geom_point() +
  labs(x = "Age (years)", y = "Mean length (cm)", 
       title = "Von Bertalanffy Growth Curve from MFCL")

# Maturity-at-length from MFCL
# Define length bins for maturity conversion: 10 to 200 cm by 2 cm
len_lower <- seq(10, by = 2, length.out = 95)
len_upper <- len_lower + 2
n_len <- length(len_lower)
len_mid <- (len_lower + len_upper) / 2

# Extract maturity-at-length from MFCL and interpolate to model length bins
mfcl_bin_lower <- len_lower
mfcl_bin_mid <- len_mid
mat_at_length_mfcl <- maturity_at_length <- as.vector(mat_at_length(base_par))

# Plot maturity-at-length
ggplot(data = data.frame(length = len_mid, maturity = maturity_at_length), 
       aes(x = length, y = maturity)) +
  geom_line() +
  geom_point() +
  labs(x = "Length (cm)", y = "Maturity", 
       title = "Maturity-at-Length from MFCL")

# Natural mortality from MFCL
M_at_age <- as.vector(m_at_age(base_rep))

# Plot M-at-age
ggplot(data = data.frame(age = ages, real_age = ages / 4, M = M_at_age), 
       aes(x = real_age, y = M)) +
  geom_line() +
  geom_point() +
  labs(x = "Age (years)", y = "M (quarterly rate)", 
       title = "Natural Mortality-at-Age from MFCL")
```

The data list is defined below and then the `get_data` function is used to set 
up some additional inputs that are required before the data list can be passed 
to `MakeADFun`.

Units 1=mt and 2=1000s of fish

```{r get-data, echo=TRUE, message=FALSE}
df_catch <- read_csv(file.path(proj_dir, "code", "rtmb", "catch-data.csv"))
df_cpue <- read_csv(file.path(proj_dir, "code", "rtmb", "cpue-data.csv"))

table(df_catch$year)
table(df_catch$fishery, df_catch$units)

# Quarterly age classes and time structure
data <- list(
  age_a = ages,
  n_age = length(ages),
  n_season = 1, # Each time step is one quarter, not seasons within years
  n_fishery = 15,
  len_bin_start = 10,  # lower edge of first length bin (cm)
  len_bin_width = 2,   # bin width (cm)
  n_len = 95           # number of length bins
)

# Use ts column as the year index (quarterly time steps)
data$first_yr <- min(df_catch$ts)
data$last_yr <- max(df_catch$ts)
data$years <- data$first_yr:data$last_yr
data$n_year <- length(data$years)
data$first_yr_catch <- data$first_yr
data$catch_units_f <- c(rep(2, 7), rep(1, 7), 2)
data$cpue_switch <- 1
data$cpue_data <- df_cpue

# Growth module data inputs ----

# Reference ages matching SS3: Growth_Age_for_L1 = 1, Growth_Age_for_L2 = 40
data$A1 <- A1
data$A2 <- A2

# Length-weight parameters as data (not estimated)
data$lw_a <- lw_params(base_ini)[1]
data$lw_b <- lw_params(base_ini)[2]

# Maturity-at-length as data vector (converted to maturity-at-age inside model)
data$maturity <- maturity_at_length

# Fecundity at length: initially equal to weight at length
# This matches SS3's fecundity_option = 3 with Eggs_alpha = 1, Eggs_beta = 1
data$fecundity_at_length <- get_weight_at_length(len_mid, data$lw_a, data$lw_b)

# Natural mortality: direct age vector from MFCL (unchanged)
data$M <- M_at_age

# Catch array: (n_year, 1, n_fishery) - map using ts directly
catch_obs_ysf <- array(0, 
                       dim = c(data$n_year, data$n_season, data$n_fishery), 
                       dimnames = list(year = data$years, season = 1, fishery = 1:data$n_fishery))
for (i in 1:nrow(df_catch)) {
  row <- df_catch[i, ]
  y_idx <- which(data$years == row$ts)
  catch_obs_ysf[y_idx, 1, row$fishery] <- row$value
}
data$catch_obs_ysf <- catch_obs_ysf

# Selectivity configuration ----

# Selectivity type per fishery: 1 = logistic, 2 = double-normal
# Fleets 11 (DOM.HL) and 15 (INDEX) use logistic; all others use double-normal
# This matches the SS3 baseline model structure
data$sel_type_f <- rep(2L, data$n_fishery)
data$sel_type_f[c(11, 15)] <- 1L
```

# Model setup

Define the parameter `list`:

```{r get-pars, echo=TRUE, message=FALSE}
# parameters <- get_parameters(data = data)
# names(parameters)
# Note: log_M removed - M-at-age now read from data
# Note: rdev_y length now matches n_year (268 quarterly time steps)

# SS3 estimated selectivity parameters (from fitted model in 01-bet-base/)
# Read directly from the SS3 control.ss_new output file
dir_bet_ss3 <- file.path(dir_model, "ss3", "01-bet-base")
est_ctl <- r4ss::SS_readctl(
  file = file.path(dir_bet_ss3, "control.ss_new"),
  datlist = file.path(dir_bet_ss3, "data_echo.ss_new"),
  verbose = FALSE
)

# Build the ss3_selex_pars matrix from estimated parameters
# Columns: peak, top_logit, ascend_se, descend_se, start_logit, end_logit
ss3_selex_pars <- matrix(NA, nrow = 15, ncol = 6)
for (f in 1:15) {
  param_rows <- grep(est_ctl$fleetnames[f], rownames(est_ctl$size_selex_parms), fixed = TRUE)
  vals <- est_ctl$size_selex_parms[param_rows, "INIT"]
  ss3_selex_pars[f, seq_along(vals)] <- vals
}

# Convert to RTMB parameterization
par_sel <- convert_ss3_selex_to_rtmb(
  ss3_pars = ss3_selex_pars,
  sel_type_f = data$sel_type_f,
  sel_lengths = seq(data$len_bin_start + data$len_bin_width / 2,
                    by = data$len_bin_width, length.out = data$n_len)
)

parameters <- list(
  log_B0 = 12,
  log_h = log(0.95),
  log_sigma_r = log(0.6),
  log_cpue_q = log(1),
  cpue_creep = 0,
  log_cpue_tau = log(0),
  log_cpue_omega = log(1),
  rdev_y = rnorm(data$n_year, 0, 0.5),
  # rdev_y = rep(0, data$n_year)
  par_sel = par_sel,  # [n_fishery, 6] matrix
  # Growth/variability leading parameters (all mapped off initially)
  log_L1  = log(L1_init),
  log_L2  = log(L2_init),
  log_k   = log(k_init),
  log_CV1 = log(CV1_init),
  log_CV2 = log(CV2_init)
)

# Store prior center values in data so get_priors() can reference them
data$prior_log_L1_mean  <- log(L1_init)
data$prior_log_L2_mean  <- log(L2_init)
data$prior_log_k_mean   <- log(k_init)
data$prior_log_CV1_mean <- log(CV1_init)
data$prior_log_CV2_mean <- log(CV2_init)
```

There is a lot of flexibility in specifying priors now:

```{r get-priors, echo=TRUE, message=FALSE}
data$priors <- get_priors(parameters = parameters, data = data)
evaluate_priors(parameters = parameters, priors = data$priors)
```

Use RTMB's `map` option to turn parameters on/off:

```{r get-map, echo=TRUE, message=FALSE}
# map <- get_map(parameters = parameters)
# Note: log_M removed - M-at-age now read from data

map_sel <- matrix(NA, nrow(parameters$par_sel), ncol(parameters$par_sel))
# map_sel[,1] <- 1:nrow(parameters$par_sel)
# map_sel[,2] <- 16:(15 + nrow(parameters$par_sel))
# map_sel[,3] <- 31:(30 + nrow(parameters$par_sel))

map <- list(
  # log_B0 = factor(NA),
  log_h = factor(NA),
  log_sigma_r = factor(NA),
  # log_cpue_q = factor(NA),
  cpue_creep = factor(NA),
  log_cpue_tau = factor(NA),
  log_cpue_omega = factor(NA),
  par_sel = as.factor(map_sel),
  # rdev_y = as.factor(rep(NA, length(parameters$rdev_y)))
  # par_sel = factor(rep(NA, length(parameters$par_sel)))  # fix all selectivity parameters
  # Growth/variability parameters mapped off (fixed at MFCL-derived defaults)
  log_L1  = factor(NA),
  log_L2  = factor(NA),
  log_k   = factor(NA),
  log_CV1 = factor(NA),
  log_CV2 = factor(NA)
)
map$par_sel
```

Using the `data`, the `parameters`, the parameter `map`, and the model 
(`bet_model`), the AD object is created using TMBs `MakeADFun` function:

```{r make-adfun, echo=TRUE, message=FALSE}
devtools::load_all()

obj <- MakeADFun(func = cmb(bet_model, data), parameters = parameters, map = map)
unique(names(obj$par))
obj$fn()
obj$gr()

obj$simulate()$cpue_log_obs
plot(obj$report()$spawning_biomass_y)
sum(obj$report()$catch_pred_ysf - data$catch_obs_ysf)
plot(data$cpue_data$value, col = 2)
lines(obj$report()$cpue_pred)
plot_catch(data = data, obj = obj)
plot_catch(data = data, obj = obj, plot_resid = TRUE)
# plot_cpue(data = data, object = obj)
# plot_biomass_spawning(data_list = list(data), object_list = list(obj))

```

List of parameters that are on:

```{r est-pars, echo=TRUE, message=FALSE}
unique(names(obj$par))
```

The objective function value given the initial parameter values:

```{r check-obj-fun, echo=TRUE, message=FALSE}
obj$fn(obj$env$last.par.best)
obj$gr(obj$env$last.par.best)
```

Load the default parameter bounds:

```{r get-par-bounds, echo=TRUE, message=FALSE}
# bnd <- get_bounds(obj, parameters = parameters)
Lwr <- rep(-Inf, length(obj$par))
Upr <- rep(Inf, length(obj$par))
Lwr[grep("log_B0", names(obj$par))] <- log(1)
Upr[grep("log_B0", names(obj$par))] <- log(exp(20))
Lwr[grep("log_q", names(obj$par))] <- log(0.1)
Upr[grep("log_q", names(obj$par))] <- log(10)
Lwr[grep("rdev_y", names(obj$par))] <- rep(-5, length(parameters$rdev_y))
Upr[grep("rdev_y", names(obj$par))] <- rep(5, length(parameters$rdev_y))
```

# Optimisation

Optimise using the `nlminb` function:

```{r run-nlminb, echo=TRUE, results="hide"}
control <- list(eval.max = 10000, iter.max = 10000)
opt <- nlminb(start = obj$par, objective = obj$fn, gradient = obj$gr, hessian = obj$he, lower = Lwr, upper = Upr, control = control)
opt <- nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, hessian = obj$he, lower = Lwr, upper = Upr, control = control)
obj$gr()

data.frame(init = unlist(parameters), value = unlist(obj$env$parList())) %>% head()

plot(data$cpue_data$value, col = 2)
lines(obj$report()$cpue_pred)

sum(obj$report()$catch_pred_ysf - data$catch_obs_ysf)

# opt <- nlminb(start = obj$par, objective = obj$fn, gradient = obj$gr, hessian = obj$he,
#               lower = bnd$lower, upper = bnd$upper, control = control)
# opt <- nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, hessian = obj$he,
#               lower = bnd$lower, upper = bnd$upper, control = control)
# save(opt, file = "opt.rda")
# load("opt.rda")
# opt <- nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, hessian = obj$he,
#               lower = bnd$lower, upper = bnd$upper, control = control)
```


## Selectivity

Visualize the selectivity curves by fleet:

```{r plot-selectivity, echo=TRUE, message=FALSE, fig.height=8, fig.width=10}
# Get selectivity from model report
rep <- obj$report()
sel_fya <- rep$sel_fya

# Fleet names
fleet_names <- c("F01_LL.NORTH", "F02_LL.US", "F03_LL.OFFSH",
                 "F04_LL.EQUAT", "F05_LL.WEST", "F06_LL.SOUTH", "F07_LL.AUS",
                 "F08_PS.ASSOC", "F09_PS.UNASS", "F10_DOM.MISC",
                 "F11_DOM.HL", "F12_JP.PS.N", "F13_JP.PL", "F14_EQ.PL",
                 "S01_INDEX")

# Create data frame for plotting
sel_df <- expand.grid(
  fishery = 1:data$n_fishery,
  age = 1:data$n_age
)
sel_df$selectivity <- sapply(1:nrow(sel_df), function(i) sel_fya[sel_df$fishery[i], 1, sel_df$age[i]])
sel_df$real_age <- sel_df$age / 4
sel_df$fleet_name <- fleet_names[sel_df$fishery]

ggplot(sel_df, aes(x = real_age, y = selectivity)) +
  geom_line() +
  facet_wrap(~fleet_name, ncol = 4) +
  labs(x = "Age (years)", y = "Selectivity",
       title = "Selectivity-at-Age by Fleet (from SS3 baseline parameters)") +
  ylim(0, 1)
```

Check that all parameters are estimable using the `check_estimability` function.
This function was taken from the `TMBhelper` package and added to the `sbt` 
package because the `TMBhelper` package is not set up as a proper package (it 
does not install properly on the GitHub servers).

```{r check-estimability, echo=TRUE, message=FALSE}
check_estimability(obj = obj)
```

Calculate standard deviations of all model parameters, including non linear 
functions of random effects and parameters specified through the `ADREPORT()` 
macro from the user template:

```{r run-report, include=FALSE}
Report <- sdreport(obj)
```

# Simulation

Simulation can be done for any data set in the model that is passed through the
`RTMB` function `OBS`. For example, the CPUE series is set up using:

```
cpue_log_obs <- log(cpue_obs)
cpue_log_obs <- OBS(cpue_log_obs)
lp <- -dnorm(x = cpue_log_obs, mean = cpue_log_pred, sd = cpue_sig, log = TRUE)
```

This allows a call to `obj$simulate()$cpue_log_obs`. For example:

```{r sim-1, echo=TRUE, message=FALSE}
# obj$simulate()$cpue_log_obs
# obj$simulate()$troll_log_obs
# obj$simulate()$aerial_log_obs
plot(log(data$cpue_data$value), col = 2)
lines(log(obj$report()$cpue_pred),lwd=2)
for (i in 1:1) lines(obj$simulate()$cpue_log_obs,col="gray90")
```

Data sets for which simulation is available include:

* cpue_log_obs

But not:

* lf_obs
* cpue_lfs

Simulation is also required for calculating OSA residuals and to use the `RTMB` 
function `checkConsistency`. Unfortunately, the `checkConsistency` does not work 
yet because  not all data types are defined using densities that have simulation 
support within the model (i.e., the AFs and LFs).

```{r check-consistency, echo=TRUE}
# chk <- checkConsistency(obj = obj, hessian = TRUE, estimate = TRUE, n = 100, observation.name	= "cpue_log_obs")
# chk
# s <- summary(chk)
# s
# s$marginal$p.value
```

# Plot outputs

## Model fits

Model fit to CPUE (Figure~\ref(fig:plot-cpue)) and the aerial surveys (Figure~\ref(fig:plot-aerial)).

```{r plot-cpue, echo=TRUE, message=FALSE, fig.cap="Model fits to CPUE."}
plot_cpue(data = data, object = obj, nsim = 10)
```

```{r plot-LL1, echo=TRUE, message=FALSE, fig.height=10, fig.cap="Model fits to LL1 length frequencies."}
plot_lf(data = data, object = obj, fishery = "LL1")
```

```{r plot-LL2, echo=TRUE, message=FALSE, fig.height=10, fig.cap="Model fits to LL2 length frequencies."}
plot_lf(data = data, object = obj, fishery = "LL2")
```

```{r plot-LL3, echo=TRUE, message=FALSE, fig.height=10, fig.cap="Model fits to LL3 length frequencies."}
plot_lf(data = data, object = obj, fishery = "LL3")
```

```{r plot-LL4, echo=TRUE, message=FALSE, fig.height=10, fig.cap="Model fits to LL4 length frequencies."}
plot_lf(data = data, object = obj, fishery = "LL4")
```

```{r plot-catch, echo=TRUE, message=FALSE}
plot_catch(data = data, object = obj)
```

```{r plot-catch-resid, echo=TRUE, message=FALSE}
plot_catch(data = data, object = obj, plot_resid = TRUE)
```

## One step ahead (OSA) residuals

One step ahead (OSA) residuals are a replacement for Pearson residuals 
(Figure~\ref(fig:osa1)).

```{r osa1, echo=TRUE, message=FALSE, fig.cap="OSA residuals."}
osa_cpue <- oneStepPredict(obj = obj, observation.name = "cpue_log_obs", 
                           method = "oneStepGeneric", trace = FALSE)
qqnorm(osa_cpue$res); abline(0, 1)
plot(osa_cpue$res); abline(-2, 0); abline(0, 0); abline(2, 0)
# osa <- oneStepPredict(obj = obj, method = "fullGaussian", discrete = FALSE, trace = FALSE)
# osa_troll <- oneStepPredict(obj = obj, observation.name = "troll_log_obs", method = "oneStepGeneric", trace = FALSE)
# qqnorm(osa_troll$res); abline(0, 1)
# plot(osa_troll$res); abline(0, 0)
# osa_aerial <- oneStepPredict(obj = obj, observation.name = "aerial_log_obs", method = "oneStepGeneric", trace = FALSE)
# qqnorm(osa$res); abline(0, 1)
# osa_gt <- oneStepPredict(obj = obj, observation.name = "gt_nrec", method = "oneStepGeneric", discrete = TRUE, trace = FALSE)
# qqnorm(osa_gt$res); abline(0, 1)
# plot(osa_gt$res); abline(-2, 0); abline(0, 0); abline(2, 0)
# osa_hsp <- oneStepPredict(obj = obj, observation.name = "hsp_nK", method = "oneStepGeneric", discrete = TRUE, trace = FALSE)
# qqnorm(osa_hsp$res); abline(0, 1)
# plot(osa_hsp$res); abline(0, 0)
# osa_pop <- oneStepPredict(obj = obj, observation.name = "pop_nP", method = "oneStepGeneric", discrete = TRUE, trace = FALSE)
# qqnorm(osa_pop$res); abline(0, 1)
# plot(osa_pop$res); abline(0, 0)
```

## Derived quantities

Recruitment deviates and recruitment (Figure~\ref(fig:plot-rec-dev), Figure~\ref(fig:plot-rec)).

```{r plot-rec-dev, echo=TRUE, message=FALSE}
plot_rec_devs(data = data, object = obj)
```

```{r plot-rec, echo=TRUE, message=FALSE}
plot_recruitment(data = data, object = obj)
```

```{r plot-M, echo=TRUE, message=FALSE}
plot_natural_mortality(data = data, object = obj)
```

```{r plot-init-n, echo=TRUE, message=FALSE}
plot_initial_numbers(data = data, object = obj)
```

```{r plot-hrate, echo=TRUE, message=FALSE}
plot_hrate(data = data, object = obj, years = 1990:2010)
```

```{r plot-sbio, echo=TRUE, message=FALSE, fig.cap="Spawning biomass by year."}
plot_biomass_spawning(data_list = list(data), object_list = list(obj))
```

# Bayesian inference

Bayesian inference can be done using the `SparseNUTS` package.

```{r run-mcmc, echo=TRUE, results="hide"}
library(SparseNUTS)

# mcmc <- sample_snuts(
#   obj = obj, metric = "auto", init = "last.par.best",
#   # lower = bnd$lower, upper = bnd$upper, # these bounds dont seem to work
#   # skip_optimization = TRUE, # Can skip for Jacobians
#   num_samples = 100, num_warmup = 75, chains = 4, cores = 4,
#   control = list(adapt_delta = 0.9), globals = sbt_globals()
# )
# save(mcmc, file = "mcmc.rda")

load("mcmc.rda")
```

```{r fig-sampler-params, echo=TRUE, results="hide", fig.height=8, fig.cap="Sampler parameters."}
plot_sampler_params(fit = mcmc, plot = TRUE)
```

```{r fig-uncertainties, echo=TRUE, results="hide", fig.cap="Comparison of Bayesian and frequentist uncertainty estimates."}
# decamod::pairs_rtmb(fit = mcmc, order = "slow", pars = 1:5)
# decamod::pairs_rtmb(fit = mcmc, order = "mismatch", pars = 1:5)
# decamod::pairs_rtmb(fit = mcmc, order = "fast", pars = 1:5)
plot_uncertainties(fit = mcmc, log = TRUE, plot = TRUE)
```

# References

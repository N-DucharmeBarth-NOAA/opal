---
title: "The BET model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The BET model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

# Introduction

The `opal` package is an R package that contains example fisheries data from western and central pacific
bigeye tuna (BET). This page provides examples using the `opal` BET model.

# Load inputs

Load the `opal` package and the `RTMB` dependency. The `ggplot2` package is
used for plotting.

```{r load-pkg, echo=TRUE, message=FALSE}
# library(ggplot2)
# library(dplyr)
library(tidyverse)
library(opal)
library(RTMB)

theme_set(theme_bw())
```

The bundled data object `wcpo_bet_data` contains all biological parameters,
catch and CPUE observations, length structure, and prior specifications needed
for the BET assessment model:

```{r load-data, echo=TRUE, message=FALSE}
data(wcpo_bet_data)
data <- wcpo_bet_data

names(data)
```

Key dimensions of the data:

```{r data-dims, echo=TRUE}
cat("Number of ages:", data$n_age, "\n")
cat("Number of years:", data$n_year, "\n")
cat("Number of fisheries:", data$n_fishery, "\n")
cat("Number of length bins:", data$n_len, "\n")
```

## Biological inputs

Natural mortality at age, maturity at length, and length-weight parameters are
all contained in the data object.

```{r plot-biology, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
ages <- data$age_a
real_age <- ages / 4

# Natural mortality
ggplot(data.frame(age = real_age, M = data$M), aes(x = age, y = M)) +
  geom_line() + geom_point() +
  labs(x = "Age (years)", y = "M (quarterly rate)",
       title = "Natural Mortality-at-Age")

# Maturity at length
len_mid <- seq(data$len_bin_start + data$len_bin_width / 2,
               by = data$len_bin_width, length.out = data$n_len)
ggplot(data.frame(length = len_mid, maturity = data$maturity),
       aes(x = length, y = maturity)) +
  geom_line() + geom_point() +
  labs(x = "Length (cm)", y = "Maturity",
       title = "Maturity-at-Length")
```

## Length composition data

Length composition observations are loaded from the bundled `wcpo_bet_lf`
long-format data object and transformed into model-ready arrays.

```{r prep-lf, echo=TRUE, message=FALSE}
data(wcpo_bet_lf)

# Pivot to wide format: one row per fishery x timestep, bins as columns
lf_wide <- wcpo_bet_lf %>%
  tidyr::pivot_wider(
    id_cols = c(fishery, year, month, ts),
    names_from = bin,
    values_from = value,
    values_fill = 0
  ) %>%
  arrange(fishery, ts)

# Extract bin columns (sorted ascending) and observation count matrix
bin_cols <- sort(as.numeric(setdiff(names(lf_wide), c("fishery", "year", "month", "ts"))))
lf_obs_counts <- as.matrix(lf_wide[, as.character(bin_cols)])

# Compute sample sizes and drop rows with zero total sample size
lf_n <- rowSums(lf_obs_counts)
keep <- lf_n > 0
lf_wide <- lf_wide[keep, ]
lf_obs_counts <- lf_obs_counts[keep, ]
lf_n <- lf_n[keep]

# Convert counts to proportions
lf_obs <- lf_obs_counts / lf_n

# Validate bin alignment with model length structure
expected_bins <- seq(data$len_bin_start, by = data$len_bin_width, length.out = data$n_len)
stopifnot(all(bin_cols == expected_bins))
  # Derive length bins from scalars (single source of truth) ----
data$len_lower <- seq(from = data$len_bin_start, by = data$len_bin_width, length.out = data$n_len)
data$len_upper <- data$len_lower + data$len_bin_width
data$len_mid   <- data$len_lower + data$len_bin_width / 2

# Note: LF data exist for fisheries 8-14, but we initially use only fisheries 8 & 9
lf_keep_fisheries <- c(8, 9)
lf_use <- lf_wide$fishery %in% lf_keep_fisheries
lf_wide <- lf_wide[lf_use, ]
lf_obs_counts <- lf_obs_counts[lf_use, ]
lf_obs <- lf_obs[lf_use, ]
lf_n <- lf_n[lf_use]

# Attach to data list
data$lf_switch         <- 9L  # multinomial offset form (recommended default) - no way
data$lf_obs_in            <- lf_obs
data$lf_n              <- lf_n
data$lf_fishery        <- as.integer(lf_wide$fishery)
data$lf_fishery_f <- unique(data$lf_fishery)
data$lf_n_f <- as.integer(table(data$lf_fishery))
data$lf_year           <- as.integer(lf_wide$ts)  # model timestep index (1-268), not calendar year
data$lf_season         <- rep(1L, nrow(lf_wide))
data$lf_minbin         <- rep(1L, data$n_fishery)
data$lf_maxbin         <- rep(data$n_len, data$n_fishery)
data$removal_switch_f  <- rep(0L, data$n_fishery)
# data$lf_var_adj        <- 1 / rep(20000, data$n_fishery)
# data$lf_var_adj[c(1, 4, 5, 6, 15)] <- 1 / 40000
data$n_lf              <- nrow(lf_obs)

  # ---- Build lf_obs OUTSIDE the AD tape ----
  # Use base R assignment (not the AD-overloaded [<-) so lf_obs stays plain numeric
  lf_n_fi <- split(lf_n, lf_fishery)

  lf_obs <- vector("list", n_f)
    for (j in seq_len(n_f)) {
      f <- lf_fishery_f[j]
      bmin <- lf_minbin[f]
      bmax <- lf_maxbin[f]
      m <- matrix(0, lf_n_f[j], bmax - bmin + 1)
      for (i in seq_len(lf_n_f[j])) {
        obs <- data$lf_obs_in[i, ]
        if (bmin > 1) obs[bmin] <- sum(obs[1:bmin])
        if (bmax < n_len_local) obs[bmax] <- sum(obs[bmax:n_len_local])
        obs <- obs[bmin:bmax]
        m[i, ] <- obs * lf_n_fi[[j]][i]
      }
      lf_obs[[j]] <- m
    }
data$lf_obs <- lf_obs
  
# Summary diagnostics
cat("Number of LF observations:", data$n_lf, "\n")
cat("Fisheries with LF data:", sort(unique(data$lf_fishery)), "\n")
cat("Timestep range:", range(data$lf_year), "\n")
```

# Model setup

## Parameters

Define the initial parameter values. Growth parameters (`log_L1`, `log_L2`,
`log_k`, `log_CV1`, `log_CV2`) and selectivity (`par_sel`) are initialised at
reasonable starting values. Load these from the bundled `wcpo_bet_parameters` 
data object:

```{r get-pars, echo=TRUE, message=FALSE}
data(wcpo_bet_parameters)

parameters <- list(
  log_B0 = 20,
  log_h = as.numeric(wcpo_bet_parameters$log_h),
  log_sigma_r = as.numeric(wcpo_bet_parameters$log_sigma_r),
  log_cpue_q = as.numeric(wcpo_bet_parameters$log_cpue_q),
  cpue_creep = as.numeric(wcpo_bet_parameters$cpue_creep),
  log_cpue_tau = as.numeric(wcpo_bet_parameters$log_cpue_tau),
  log_cpue_omega = as.numeric(wcpo_bet_parameters$log_cpue_omega),
  log_lf_tau = log(1 / rep(20000, data$n_fishery)),
  log_L1 = as.numeric(wcpo_bet_parameters$log_L1),
  log_L2 = as.numeric(wcpo_bet_parameters$log_L2),
  log_k = as.numeric(wcpo_bet_parameters$log_k),
  log_CV1 = as.numeric(wcpo_bet_parameters$log_CV1),
  log_CV2 = as.numeric(wcpo_bet_parameters$log_CV2),
  par_sel = as.matrix(wcpo_bet_parameters$par_sel),
  rdev_y = as.numeric(wcpo_bet_parameters$rdev_y)
)
parameters$log_lf_tau[c(1, 4:6, 15)] <- log(1 / 40000)
```

## Priors

Priors are specified using `get_priors()`. The data object already contains
prior center values for growth parameters:

```{r get-priors, echo=TRUE, message=FALSE}
data$priors <- get_priors(parameters = parameters, data = data)
evaluate_priors(parameters = parameters, priors = data$priors)
```

## Parameter map

Use RTMB's `map` option to turn parameters on/off. Parameters mapped to
`factor(NA)` are fixed at their initial values:

```{r get-map, echo=TRUE, message=FALSE}
map_sel <- matrix(NA, nrow(parameters$par_sel), ncol(parameters$par_sel))
map_sel[8, 1] <- 1
map_sel[9, 1] <- 2
map_sel[8, 3] <- 3
map_sel[9, 3] <- 4
map_sel[8, 4] <- 5
map_sel[9, 4] <- 6
map_rdev <- rep(NA, length(parameters$rdev_y))

map <- list(
  # log_B0 = factor(NA),
  log_h = factor(NA),
  log_sigma_r = factor(NA),
  # log_cpue_q = factor(NA),
  cpue_creep = factor(NA),
  log_cpue_tau = factor(NA),
  log_cpue_omega = factor(NA),
  log_lf_tau = factor(rep(NA, data$n_fishery)),
  log_L1  = factor(NA),
  log_L2  = factor(NA),
  log_k   = factor(NA),
  log_CV1 = factor(NA),
  log_CV2 = factor(NA),
  par_sel = factor(map_sel)
  # rdev_y = as.factor(map_rdev),
)
```

## Build the AD object

Using the `data`, the `parameters`, the parameter `map`, and the model
(`opal_model`), the AD object is created using RTMB's `MakeADFun` function:

```{r make-adfun, echo=TRUE, message=FALSE}
data$lf_switch <- 1
obj <- MakeADFun(func = cmb(opal_model, data), parameters = parameters, map = map)
unique(names(obj$par))
obj$fn()
obj$gr()
```

Inspect initial model outputs:

```{r init-checks, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
plot(obj$report()$spawning_biomass_y, type = "l",
     xlab = "Time step", ylab = "Spawning biomass (mt)",
     main = "Initial spawning biomass trajectory")

plot_catch(data = data, obj = obj)
```

## Parameter bounds

```{r get-par-bounds, echo=TRUE, message=FALSE}
Lwr <- rep(-Inf, length(obj$par))
Upr <- rep(Inf, length(obj$par))
Lwr[grep("log_B0", names(obj$par))] <- log(1)
Upr[grep("log_B0", names(obj$par))] <- log(exp(22))
Lwr[grep("log_cpue_q", names(obj$par))] <- log(0.1)
Upr[grep("log_cpue_q", names(obj$par))] <- log(10)
Lwr[grep("rdev_y", names(obj$par))] <- rep(-5, length(parameters$rdev_y))
Upr[grep("rdev_y", names(obj$par))] <- rep(5, length(parameters$rdev_y))
# Lwr[grep("par_sel", names(obj$par))] <- rep(-5, length(parameters$par_sel))
# Upr[grep("par_sel", names(obj$par))] <- rep(5, length(parameters$par_sel))
bounds <- data.frame(par = names(obj$par), lower = Lwr, upper = Upr)
```

# Optimisation

Optimise using the `nlminb` function, do it twice to be sure to be sure (said with Irish accent):

```{r run-nlminb, echo=TRUE, results="hide"}
obj <- MakeADFun(func = cmb(opal_model, data), parameters = parameters, map = map)
control <- list(eval.max = 10000, iter.max = 10000)
opt <- nlminb(start = obj$par, objective = obj$fn, gradient = obj$gr,
              hessian = obj$he, lower = Lwr, upper = Upr, control = control)
opt <- nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr,
              hessian = obj$he, lower = Lwr, upper = Upr, control = control)
max(obj$gr())
obj$report()$lp_prior
obj$report()$lp_penalty
obj$report()$lp_rec
sum(obj$report()$lp_cpue)
sum(obj$report()$lp_lf)
x <- seq(0, 0.003, 0.0000001)
plot(x, posfun(x = x, eps = 0.001)$penalty)

check_estimability(obj = obj)

```

Compare initial and estimated parameter values:

```{r opt-results, echo=TRUE, message=FALSE}
data.frame(init = unlist(parameters), 
           value = unlist(obj$env$parList(obj$env$last.par.best))) %>%
  mutate(par = rownames(.)) %>%
  left_join(bounds, by = join_by(par)) %>%
  head(10)
```

## Length composition fits

Inspect predicted vs observed length compositions:

```{r lf-diagnostics, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
lf_rep <- obj$report()
lf_pred <- lf_rep$lf_pred
names(lf_pred) <- data$lf_fishery_f
colnames(lf_pred[[1]]) <- data$len_mid
colnames(lf_pred[[2]]) <- data$len_mid

lf_year_list <- split(data$lf_year, data$lf_fishery_f)

# Predicted: long data frame with obs id
df_pred <- map_dfr(seq_along(lf_pred), function(i) {
  m <- lf_pred[[i]]
  yrs <- lf_year_list[[i]]
  as.data.frame.table(m, responseName = "pred", stringsAsFactors = FALSE) %>%
    rename(id = Var1, length = Var2) %>%
    mutate(fishery = names(lf_pred)[i],
           id = as.integer(factor(id, levels = unique(id))),
           year = yrs[id],
           length = as.numeric(length))
})

# Observed: long data frame with obs id
df_obs <- data.frame(data$lf_obs_in)
names(df_obs) <- data$len_mid
df_obs <- df_obs %>%
  mutate(year = data$lf_year, fishery = as.character(data$lf_fishery)) %>%
  group_by(fishery) %>%
  mutate(id = row_number()) %>%
  ungroup() %>%
  pivot_longer(cols = -c(year, fishery, id), names_to = "length", values_to = "obs") %>%
  mutate(length = as.numeric(length))

# Join on id + fishery + length (unique key)
df <- left_join(df_obs, df_pred, by = c("id", "fishery", "length")) %>%
  select(-year.y) %>%
  rename(year = year.x)

# Plot fishery 8
ggplot(df %>% filter(fishery == "8", year %in% 146:188), aes(x = length)) +
  geom_col(aes(y = obs), fill = "grey70", width = 2) +
  geom_line(aes(y = pred), colour = "red3", linewidth = 0.7) +
  facet_wrap(~ year, scales = "free_y", ncol = 6) +
  labs(x = "Length (cm)", y = "Proportion",
       title = "Length composition: Fishery 8",
       subtitle = "Grey bars = observed, red line = predicted") +
  theme(strip.text = element_text(size = 7),
        axis.text = element_text(size = 6))

# Plot fishery 9
ggplot(df %>% filter(fishery == "9", year %in% 146:188), aes(x = length)) +
  geom_col(aes(y = obs), fill = "grey70", width = 2) +
  geom_line(aes(y = pred), colour = "red3", linewidth = 0.7) +
  facet_wrap(~ year, scales = "free_y", ncol = 6) +
  labs(x = "Length (cm)", y = "Proportion",
       title = "Length composition: Fishery 9",
       subtitle = "Grey bars = observed, red line = predicted") +
  theme(strip.text = element_text(size = 7),
        axis.text = element_text(size = 6))
# # Summary: total NLL contribution by fishery
# lf_nll_by_fishery <- tapply(lf_rep$lp_lf, data$lf_fishery, sum)
# cat("Length composition NLL by fishery:\n")
# print(round(lf_nll_by_fishery, 1))
# 
# # Example: overlay observed and predicted for a single observation
# obs_i <- 3
# plot_df <- data.frame(
#   length = rep(len_mid, 2),
#   proportion = c(data$lf_obs[obs_i, ], lf_pred[obs_i, ]),
#   type = rep(c("Observed", "Predicted"), each = data$n_len)
# )
# 
# ggplot(plot_df, aes(x = length, y = proportion, colour = type)) +
#   geom_line() +
#   labs(x = "Length (cm)", y = "Proportion",
#        title = paste("Fishery", data$lf_fishery[obs_i],
#                      "- Year", data$lf_year[obs_i]))

```

Inspect fitted CPUE and catch:

```{r opt-catch, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
plot(data$cpue_data$value, col = 2, pch = 16,
     xlab = "Time step", ylab = "CPUE", main = "CPUE: observed vs predicted")
lines(exp(obj$simulate()$cpue_log_obs), lwd = 2, col = "gray70")
lines(obj$report()$cpue_pred, lwd = 2)
```

```{r opt-cpue, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
sum(obj$report()$catch_pred_ysf - data$catch_obs_ysf)
plot_catch(data = data, obj = obj)
plot_catch(data = data, obj = obj, plot_resid = TRUE)
```

Inspect estimated spawning biomass trajectory:

```{r opt-spbio, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
plot(obj$report()$spawning_biomass_y, type = "l",
     xlab = "Time step", ylab = "Spawning biomass (mt)",
     main = "Estimated spawning biomass trajectory",
     ylim = c(0, max(obj$report()$spawning_biomass_y) * 1.2))
```

## Selectivity

Visualise the selectivity curves by fleet:

```{r plot-selectivity, echo=TRUE, message=FALSE, fig.height=8, fig.width=10, fig.cap="Selectivity-at-Age by Fleet"}
rep <- obj$report()
sel_fya <- rep$sel_fya

fleet_names <- c("F01_LL.NORTH", "F02_LL.US", "F03_LL.OFFSH",
                 "F04_LL.EQUAT", "F05_LL.WEST", "F06_LL.SOUTH", "F07_LL.AUS",
                 "F08_PS.ASSOC", "F09_PS.UNASS", "F10_DOM.MISC",
                 "F11_DOM.HL", "F12_JP.PS.N", "F13_JP.PL", "F14_EQ.PL",
                 "S01_INDEX")

sel_df <- expand.grid(fishery = 1:data$n_fishery, age = 1:data$n_age)
sel_df$selectivity <- sapply(1:nrow(sel_df), function(i) {
  sel_fya[sel_df$fishery[i], 1, sel_df$age[i]]
})
sel_df$real_age <- sel_df$age / 4
sel_df$fleet_name <- fleet_names[sel_df$fishery]

ggplot(sel_df, aes(x = real_age, y = selectivity)) +
  geom_line() +
  facet_wrap(~fleet_name, ncol = 4) +
  labs(x = "Age (years)", y = "Selectivity") +
  ylim(0, 1)
```

## Diagnostics

Check that all parameters are estimable using the `check_estimability` function:

```{r check-estimability, echo=TRUE, message=FALSE, error = TRUE}
check_estimability(obj = obj)
```

Calculate standard deviations of all model parameters:

```{r run-sdreport, echo=TRUE, message=FALSE}
Report <- sdreport(obj)
```

# Simulation

The CPUE series is set up using RTMB's `OBS` mechanism inside the model, which
allows simulation via `obj$simulate()`. For example:

```{r sim-1, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
plot(log(data$cpue_data$value), col = 2, pch = 16,
     xlab = "Time step", ylab = "log(CPUE)", main = "Observed vs simulated CPUE")
lines(log(obj$report()$cpue_pred), lwd = 2)
for (i in 1:5) lines(obj$simulate()$cpue_log_obs, col = "gray70")
```

## One step ahead (OSA) residuals

OSA residuals are a replacement for Pearson residuals:

```{r osa1, echo=TRUE, message=FALSE, fig.height=4, fig.width=7}
osa_cpue <- oneStepPredict(obj = obj, observation.name = "cpue_log_obs",
                           method = "oneStepGeneric", trace = FALSE)
qqnorm(osa_cpue$res)
abline(0, 1)
plot(osa_cpue$res, xlab = "Index", ylab = "OSA residual")
abline(h = c(-2, 0, 2), lty = c(2, 1, 2))
```
